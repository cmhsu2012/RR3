#Construct Lz_abs using elliptic curves
E=EllipticCurve("11a3");
Ez=E.base_extend(Qz);
Lz_abs.<lz_ell>=Ez.division_field(5)

#Construct Lz as relative extension of Qz
from_Qz_to_Lz_abs=Qz.Hom(Lz_abs).an_element();
assert from_Qz_to_Lz_abs(1)!=0, "Homomorphism from Qz into Lz_abs is trivial"
Lz_over_Qz.<lz_rel>=Lz_abs.relativize(from_Qz_to_Lz_abs);
Lz_over_Qz_to_Lz_abs, Lz_abs_to_Lz_over_Qz = Lz_over_Qz.structure();

#Fix zeta_p in Lz
zeta_Lz=from_Qz_to_Lz_abs(zeta_Qz);

#Choose primitive element for the relative extension Lz/Qz
Lz_gen=Lz_over_Qz_to_Lz_abs(Lz_over_Qz.0);

#Choose a generator of the Galois group of Lz/Qz
sigma_Lz = None
for aut in Lz_abs.galois_group():
    if aut(zeta_Lz) == zeta_Lz and not aut.multiplicative_order()==1:
        sigma_Lz = aut
        break
assert sigma_Lz.multiplicative_order()==5, "sigma_Lz has incorrect order";

#Construct c1 from generator of Lz/Qz
c1_element_Lz = sum([zeta_Lz^i*((sigma_Lz^i)(Lz_gen)) for i in range(5)])
c1_element_rel=Lz_abs_to_Lz_over_Qz(c1_element_Lz)
assert c1_element_rel^5 == c1_element_rel.relative_norm()
c1_element = c1_element_rel.relative_norm()
Lz_Kummer.<lz_kummer> = NumberField(Qz.extension(x^5-c1_element,'c1_element').absolute_polynomial())

#Check that the Kummer extension generated by c_1 is equal to Lz_abs
assert Kummer_equal_check(Lz_Kummer,Lz_abs)

###In this section, we find our element gamma that gives the candidates for the a1 and b2-sides

#Construct relative norm as linear transformation from SUKz_over_Qz_ell0 to SUQz_ell0 (note that these matrices live in GF(5))
relative_norm_vectors=[list((SUQz_ell0.log(u.relative_norm()))) for u in SUKz_over_Qz_ell0.gens_values()]
relative_norm_matrix= Matrix(GF(5),relative_norm_vectors).transpose();

#Construction delta-acton as linear transformation from SUKz_abs_ell0 to itself
delta_action_vectors=[list(SUKz_over_Qz_ell0.log(Kz_abs_to_Kz_over_Qz(delta(Kz_over_Qz_to_Kz_abs(u))))) for u in SUKz_over_Qz_ell0.gens_values()]
delta_action_matrix= Matrix(GF(5),delta_action_vectors).transpose();

#Impose condition that beta is omega^2-isotypic
delta_action_matrix_omega = delta_action_matrix - omega(2)*matrix.identity(30)

#Compute gamma in Kz
matrix_for_finding_gamma=Matrix(GF(5),relative_norm_matrix.rows()+delta_action_matrix_omega.rows())
c1_vector=vector(GF(5),list(SUQz_ell0.log(SUQz_ell0(c1_element))));
c1_vector_with_omega_action = vector(GF(5),list(SUQz_ell0.log(SUQz_ell0(c1_element)))+list(0*delta_action_matrix.rows()[0]))
gamma_vector=matrix_for_finding_gamma.solve_right(c1_vector_with_omega_action.column()).column(0);
gamma_Kz_over_Qz=SUKz_over_Qz_ell0.exp(gamma_vector);
gamma_abs = mod_p_powers(SUKz_abs_ell0,Kz_over_Qz_to_Kz_abs(mod_p_powers(SUKz_over_Qz_ell0,gamma_Kz_over_Qz)))

#Check that the relative norm of gamma in Kz/Qz generates Lz_abs
Lz_gamma.<lz_gamma> = NumberField(Qz.extension(x^5-Kz_abs_to_Kz_over_Qz(gamma_abs).relative_norm(),'gamma_element').absolute_polynomial())
assert Kummer_equal_check(Lz_gamma,Lz_abs)

#Check that gamma has omega^2-action
assert omega_action_test(gamma_abs,omega(2))

#Define D0_gamma, D1_gamma, D2_gamma
D0_gamma= mod_p_powers(SUKz_abs_ell0,D_0_operator(sigma,gamma_abs))
D1_gamma = mod_p_powers(SUKz_abs_ell0,D_1_operator(sigma,gamma_abs))
D2_gamma = mod_p_powers(SUKz_abs_ell0,D_2_operator(sigma,gamma_abs))

#Check that relationship between D_0 and D_1
assert D0_gamma==mod_p_powers(SUKz_abs_ell0,Kz_over_Qz_to_Kz_abs(gamma_Kz_over_Qz.relative_norm()))
assert mod_p_powers(SUKz_abs_ell0,SUKz_abs_ell0.exp(vector(SUKz_abs_ell0.log(sigma(D1_gamma)/D1_gamma))+vector(SUKz_abs_ell0.log(D0_gamma))))==1

#Check that Lemma 5.5.1 holds
assert SUKz_abs_ell0.log(mod_p_powers(SUKz_abs_ell0,D_1_operator(sigma^3,gamma_abs)))==SUKz_abs_ell0.log(mod_p_powers(SUKz_abs_ell0,D_1_operator(sigma,gamma_abs^2)))

#Check if D1_gamma is p-power free
if p_power_check(D1_gamma):
    print("D1_gamma is p-power free.")
    D1_gamma_free = D1_gamma
elif p_power_10_check(D1_gamma):
    print("D1_gamma is not p-power free -- adjusting now.")
    D1_gamma_free = p_power_adjustment_10(D1_gamma)
    assert p_power_check(D1_gamma_free)
    print("We've adjusted so that D1_gamma is p-power free.")
else:
    print("D1_gamma is not p-power free and further adjustment is needed.")

#Check if D2_gamma is p-power free
if p_power_check(D2_gamma):
    print("D2_gamma is p-power free.")
    D2_gamma_free = D2_gamma
elif p_power_10_check(D2_gamma):
    print("D2_gamma is not p-power free -- adjusting now.")
    D2_gamma_free = p_power_adjustment_10(D2_gamma)
    assert p_power_check(D2_gamma_free)
    print("We've adjusted so that D2_gamma is p-power free.")
else:
    print("D2_gamma is not p-power free and further adjustment is needed.")

#Check that the extension Kz(sqrt[p]{D1_gamma})/Q has correct splitting patterns for primes of characteristic ell0 (there should be 16 ramified primes and 4 primes that are either inert or split)
ramified_primes_D1_gamma, split_primes_D1_gamma,inert_primes_D1_gamma=Ell0_splitting_patterns(D1_gamma_free)
print(ramified_primes_D1_gamma,split_primes_D1_gamma,inert_primes_D1_gamma)
assert len(ramified_primes_D1_gamma)==16
assert len(split_primes_D1_gamma)==4 or len(inert_primes_D1_gamma)==4